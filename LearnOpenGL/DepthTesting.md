# Depth testing
物体の前後を正しく描画するために、OpenGLは深度テストを使用する。
```cpp
glEnable(GL_DEPTH_TEST);
```
を使用して深度テストを有効にすることで、model行列、view行列、projection行列を使用して計算された深度地に基づいて、フラグメントが描画されるかを
決定する。基本的にはGPUは**early depth test**を使用して、フラグメントシェーダーが実行される前に深度テストを行う。そのようにすることで、処理の重い
フラグメントシェーダーを減らすことができる。  
深度テストを行うことで深度値が深度バッファに保存される。その値を解放してあげないと深度値がたまっていく。
```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```
毎フレーム解放してあげることで深度値がたまることを防ぐことができる。  
透明なオブジェクトは不透明なオブジェクトの手前に描画される。もし、深度地が更新されてそれが反映される場合、奥のオブジェクトは描画されない。
このようなことを防ぐために、深度値のテストはするが深度バッファを更新しないようにすることが出来る。
```cpp
glDepthMask(GL_FALSE);
```

## Depth test 
深度テストの動作を変更するには、`glDepthFunc`関数を使用する。デフォルトでは、`GL_LESS`に設定されている。
| 定数               | 説明                                     |
| ---------------- | -------------------------------------- |
| **GL\_ALWAYS**   | 深度テストが常に合格する                           |
| **GL\_NEVER**    | 深度テストが常に不合格になる                         |
| **GL\_LESS**     | フラグメントの深度値が、深度バッファに保存されている値より小さい場合に合格  |
| **GL\_EQUAL**    | フラグメントの深度値が、深度バッファに保存されている値と等しい場合に合格   |
| **GL\_LEQUAL**   | フラグメントの深度値が、深度バッファに保存されている値以下の場合に合格    |
| **GL\_GREATER**  | フラグメントの深度値が、深度バッファに保存されている値より大きい場合に合格  |
| **GL\_NOTEQUAL** | フラグメントの深度値が、深度バッファに保存されている値と等しくない場合に合格 |
| **GL\_GEQUAL**   | フラグメントの深度値が、深度バッファに保存されている値以上の場合に合格    |


## Depth value precision
深度値の値は[0.0,1.0]の範囲で保存される。これは単にz値を線形にマッピングしたものではなく、非線形なものになる。具体的には
z値がカメラに近いほど、深度値の精度が高くなる。

```glsl
void main(){
	FragColor=vec4(vec3(gl_FragCoord.z).1.0);
}
```
このようにすることで深度値を可視化することが出来る。深度値が0.0に近いほど黒く、1.0に近いほど白くなる。

### Z-fighting
Z-fightingは2つの面が非常に近いときに、深度バッファの精度が足りずに面の境界がちらつく現象である。
![](https://learnopengl.com/img/advanced/depth_testing_z_fighting.png)

この問題を解決するには
* 三角形同士が近い位置で重なり合うようにオブジェクトを配置しない。例えば、壁と床が同じ位置にある場合は、壁を少し上に移動する。
* ニア平面を出来るだけ遠くに設定する。ニアの平面付近では深度の精度が非常に高くなるため、ニア平面を視点から遠ざけることによって
深度バッファの精度が向上する。
* より高精度の深度バッファを使用する。デフォルトでは24bit精度だが、現在の多くのGPUでは32bit深度バッファをサポートする。
